Introduction
============

The idea of all this was to develop a some car-driving software (controller) that could avoid collision and drive to waypoints in the MORSE simulator. The intention being the controller could be used on an R/C car with a Hokuyo LIDAR and typical drone sensors such as GPS and compass. Something like the cars entered into the Sparkfun autonomous vehicle competion.

Dependencies
============

MORSE installation instructions are here:
http://www.openrobots.org/morse/doc/latest/user/installation.html

This project is using the MORSE socket interface so you don't need ROS or YARP.

The graphical programs are using PyQt4 and PyQWT. Unfortunately they are python2 only.

On Fedora 19 for example, install all the dependencies except for MORSE using yum:
yum install blender python3 PyQWT

Directory Layout
================

simulation
----------

Contains files used by MORSE. These files describe the robot platform, actuators, sensors and environment.

The robot is currently a car with a LIDAR on the front for collision detection and a few other sensors like position and orientation.

The important files here are:
empty-hummer.py: puts the car on a plane with no obstacles. The plane is not infinite and the car will go off the edge. Press F11 in morse to bring it back.
land-hummer.py: the same car in a slightly undulating terrain with trees and buildings. This environment comes from the morse installation. Again the car will fall off the edge.

control 
-------

Code which reacts to senors and user input and sets actuator values accordingly. This is intended to run on the car's on-board computer.

The most important files here are:
main.py: this is the entry point to the controller. It connects with the simulated sensors and actuators. It also provides two servers. One is a status server which is a great spew of information about sensor values and other important stuff inside the controller program. The other server is for users to send commands to the car to do stuff and change various parameters of the controller.

user
----

Code that is useful for telling the car what to do and looking at status information, usually to determine why the car is not doing what I told it to do. 

The important files here are:
cmd.py: this is a command line program for sending commands to the car. When run, it will connect to the car's command server and then send each command listed in the supplied text file. Example command files are given in the cmd subdirectory.
monitor.py: this is a GUI program that reads the controller's status server and displays most of the interesting data big numbers.
graph.py: another GUI like monitory.py but shows the variables graphed over time. This is more useful for determining wtf just happend.
map.py: another GUI, this shows the bird's eye view of the car in it's environment. It shows things like the position, heading and waypoints.

Usage
=====

I like to do this in 4 separate terminals, I will refer to the them as Term 1, Term 2 etc.

1. In Term 1, start morse
cd simulator
morse run empty-hummer.py

The morse window should appear with a hummer in the middle of the window.

2. In Term 2, start the controller
cd controller
./main.py

The controller should display a few messages saying it has connected with various sensors in morse.

3. In Term 3, start some monitoring programs.
cd user
./monitor.py &
./map.py &
./graph.py &

* Note: empty-hummer.py and land-hummer.py have fastmode=True, which turns off textures and lighting and everything that makes a 3d simulation look nice.
env = Environment('./environments/empty.blend', fastmode=True)
This is because I have an i3 with intel gpu and 2GB of RAM. Set it to fastmode=False if you have a good machine.

4. In Term 4, tell the car to do something, drive to a waypoint for example. There are example command files in user/cmds. example-go.cmd changes some paremeters of the speed controller, sets some waypoints and then enables the waypoint controller, causing the car to start driving to the first waypoint.
cd user
./cmd.py cmds/example-go.cmd

